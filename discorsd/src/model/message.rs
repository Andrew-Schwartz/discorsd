use std::collections::HashSet;
use std::convert::TryFrom;
use std::fmt::{Display, Formatter, Write};

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

use crate::model::channel::{Channel, ChannelType};
use crate::model::components::ActionRow;
use crate::model::emoji::Emoji;
use crate::model::ids::*;
pub use crate::model::ids::MessageId;
use crate::model::new_interaction::InteractionType;
use crate::model::Png;
use crate::model::user::User;
use crate::serde_utils::BoolExt;

/// Represents a message sent in a channel within Discord.
#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct Message {
    /// id of the message
    pub id: MessageId,
    /// id of the channel the message was sent in
    #[serde(rename = "channel_id")]
    pub channel: ChannelId,
    // /// id of the guild the message was sent in
    // #[serde(skip_serializing_if = "Option::is_none")]
    // pub guild_id: Option<GuildId>,
    /// the author of this message
    ///
    /// The author object follows the structure of the user object, but is only a valid user in the
    /// case where the message is generated by a user or bot user. If the message is generated by a
    /// webhook, the author object corresponds to the webhook's id, username, and avatar. You can
    /// tell if a message is generated by a webhook by checking for [webhook_id](Message::webhook_id).
    pub author: User,
    // /// member properties for this message's author
    // ///
    // /// The member object exists in
    // /// [MessageCreate](crate::shard::dispatch::MessageCreate) and
    // /// [MessageUpdate](crate::shard::dispatch::MessageUpdate) events from text-based
    // /// guild channels. This allows bots to obtain real-time member data without requiring bots to
    // /// store member state in memory.
    // #[serde(skip_serializing_if = "Option::is_none")]
    // pub member: Option<GuildMemberUserless>,
    /// contents of the message
    pub content: String,
    /// when this message was sent
    pub timestamp: DateTime<Utc>,
    /// when this message was edited (or null if never)
    pub edited_timestamp: Option<DateTime<Utc>>,
    /// whether this was a TTS message
    pub tts: bool,
    /// whether this message mentions everyone
    pub mention_everyone: bool,
    /// users specifically mentioned in the message
    ///
    /// array of user objects, with an additional partial member field
    ///
    /// The user objects in the mentions array will only have the partial [member](Message::member)
    /// field present in [MessageCreate](crate::shard::dispatch::MessageCreate) and
    /// [MessageUpdate](crate::shard::dispatch::MessageUpdate) events from text-based guild channels.
    pub mentions: Vec<User>,
    /// roles specifically mentioned in this message
    pub mention_roles: Vec<RoleId>,
    /// channels specifically mentioned in this message
    ///
    /// Not all channel mentions in a message will appear. Only textual channels that are visible to
    /// everyone in a lurkable guild will ever be included. Only crossposted messages (via Channel
    /// Following) currently include `mention_channels` at all. If no mentions in the message meet
    /// these requirements, this field will not be sent.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub mention_channels: Vec<ChannelMention>,
    /// any attached files
    pub attachments: Vec<Attachment>,
    /// any embedded content
    pub embeds: Vec<Embed>,
    /// reactions to the message
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub reactions: Vec<Reaction>,
    /// used for validating a message was sent
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nonce: Option<String>,
    /// whether this message is pinned
    pub pinned: bool,
    /// if the message is generated by a webhook, this is the webhook's id
    #[serde(skip_serializing_if = "Option::is_none")]
    pub webhook_id: Option<WebhookId>,
    /// sent with Rich Presence-related chat embeds
    #[serde(skip_serializing_if = "Option::is_none")]
    pub activity: Option<MessageActivity>,
    /// sent with Rich Presence-related chat embeds
    #[serde(skip_serializing_if = "Option::is_none")]
    pub application: Option<MessageApplication>,
    ///    if the message is a response to an Interaction, this is the id of the interaction's application
    #[serde(skip_serializing_if = "Option::is_none")]
    pub application_id: Option<ApplicationId>,
    /// reference data sent with crossposted messages and replies
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message_reference: Option<MessageReference>,
    /// message flags combined as a bitfield
    #[serde(default, skip_serializing_if = "MessageFlags::is_empty")]
    pub flags: MessageFlags,
    // todo given what this documentation says, maybe should be `Option<Option<Message>>`?
    /// the message associated with the [message_reference](Message::message_reference)
    ///
    /// This field is only returned for messages with a [type](Message::message_type) of `19` (REPLY).
    /// If the message is a reply but the `referenced_message` field is not present, the backend did
    /// not attempt to fetch the message that was being replied to, so its state is unknown.
    /// If the field exists but is `None`, the referenced message was deleted.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub referenced_message: Option<Box<Message>>,
    /// sent if the message is a response to an Interaction
    #[serde(skip_serializing_if = "Option::is_none")]
    pub interaction: Option<MessageInteraction>,
    /// the thread that was started from this message, includes thread member object
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thread: Option<Channel>,
    /// sent if the message contains components like buttons, action rows, or other interactive components
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub components: Vec<ActionRow>,
    /// sent if the message contains stickers
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub sticker_items: Vec<StickerItem>,
    /// A generally increasing integer (there may be gaps or duplicates) that represents the approximate position of the message in a thread, it can be used to estimate the relative position of the message in a thread in company with total_message_sent on parent thread
    #[serde(skip_serializing_if = "Option::is_none")]
    pub position: Option<usize>,
    /// type of message
    #[serde(rename = "type")]
    pub message_type: MessageType,
}

impl Message {
    pub fn cmid(&self) -> ChannelMessageId {
        self.into()
    }
}

id_impl!(Message => MessageId);

// todo why isn't this just a tuple??? (maybe can make a trait ext bound that either order works for)
#[derive(Copy, Clone, Eq, PartialEq, Debug, Hash)]
pub struct ChannelMessageId {
    pub channel: ChannelId,
    pub message: MessageId,
}

impl From<Message> for ChannelMessageId {
    fn from(m: Message) -> Self {
        Self {
            channel: m.channel,
            message: m.id,
        }
    }
}

impl From<&Message> for ChannelMessageId {
    fn from(m: &Message) -> Self {
        Self {
            channel: m.channel,
            message: m.id,
        }
    }
}

// impl From<&mut Message> for MessageRef {
//     fn from(m: &mut Message) -> Self {
//         MessageRef {
//             channel: m.channel_id,
//             message: m.id,
//         }
//     }
// }

serde_repr! {
    pub enum MessageType: u8 {
        Default = 0,
        RecipientAdd = 1,
        RecipientRemove = 2,
        Call = 3,
        ChannelNameChange = 4,
        ChannelIconChange = 5,
        ChannelPinnedMessage = 6,
        UserJoin = 7,
        GuildBoost = 8,
        GuildBoostTier1 = 9,
        GuildBoostTier2 = 10,
        GuildBoostTier3 = 11,
        ChannelFollowAdd = 12,
        GuildDiscoveryDisqualified = 14,
        GuildDiscoveryRequalified = 15,
        GuildDiscoveryGracePeriodInitialWarning = 16,
        GuildDiscoveryGracePeriodFinalWarning = 17,
        ThreadCreated = 18,
        Reply = 19,
        ChatInputCommand = 20,
        ThreadStarterMessage = 21,
        GuildInviteReminder = 22,
        ContextMenuCommand = 23,
        AutoModerationAction = 24,
    }
}

#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct MessageActivity {
    /// type of message activity
    #[serde(rename = "type")]
    pub activity_type: MessageActivityType,
    /// party_id from a Rich Presence event
    #[serde(skip_serializing_if = "Option::is_none")]
    pub party_id: Option<String>,
}

serde_repr! {
    pub enum MessageActivityType: u8 {
        Join = 1,
        Spectate = 2,
        Listen = 3,
        JoinRequest = 5,
    }
}

#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct MessageApplication {
    /// id of the application
    pub id: ApplicationId,
    /// id of the embed's image asset
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cover_image: Option<String>,
    /// application's description
    pub description: String,
    /// id of the application's icon
    pub icon: Option<String>,
    /// name of the application
    pub name: String,
}
id_impl!(MessageApplication => ApplicationId);

#[derive(Deserialize, Serialize, Debug, Clone, Eq, PartialEq)]
pub struct MessageReference {
    /// id of the originating message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message_id: Option<MessageId>,
    /// id of the originating message's channel
    ///
    /// optional when creating a reply, but will always be present when receiving an event/response
    /// that includes this data model.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub channel_id: Option<ChannelId>,
    /// id of the originating message's guild
    #[serde(skip_serializing_if = "Option::is_none")]
    pub guild_id: Option<GuildId>,
}

impl MessageReference {
    pub fn reply(message: MessageId) -> Self {
        Self {
            message_id: Some(message),
            channel_id: None,
            guild_id: None,
        }
    }
}

bitflags! {
    pub struct MessageFlags: u16 {
        /// this message has been published to subscribed channels (via Channel Following)
		const CROSSPOSTED = 1 << 0;
        /// this message originated from a message in another channel (via Channel Following)
		const IS_CROSSPOST = 1 << 1;
        /// do not include any embeds when serializing this message
		const SUPPRESS_EMBEDS = 1 << 2;
        /// the source message for this crosspost has been deleted (via Channel Following)
		const SOURCE_MESSAGE_DELETED = 1 << 3;
        /// this message came from the urgent message system
		const URGENT = 1 << 4;
		/// this message is only visible to the user who invoked the Interaction
		const EPHEMERAL = 1 << 6;
        /// this message is an Interaction Response and the bot is "thinking"
		const LOADING = 1 << 7;
        /// this message failed to mention some roles and add their members to the thread
        const FAILED_TO_MENTION_SOME_ROLES_IN_THREAD = 1 << 8;
        /// Undocumented so far
        const UNKNOWN_512 = 1 << 9;
        /// Undocumented so far
        const UNKNOWN_1024 = 1 << 10;
    }
}
serde_bitflag!(MessageFlags: u16);
impl Default for MessageFlags {
    fn default() -> Self {
        Self::empty()
    }
}

/// This is sent on the message object when the message is a response to an Interaction.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct MessageInteraction {
    /// id of the interaction
    pub id: InteractionId,
    /// the type of interaction
    #[serde(rename = "type")]
    pub kind: InteractionType,
    /// the name of the ApplicationCommand
    pub name: String,
    /// the user who invoked the interaction
    pub user: User,
}

#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct Sticker {
    /// id of the sticker
    pub id: StickerId,
    /// id of the pack the sticker is from
    pub pack_id: Option<StickerPackId>,
    /// name of the sticker
    pub name: String,
    /// description of the sticker
    pub description: String,
    /// a comma-separated list of tags for the sticker
    pub tags: Option<String>,
    /// sticker preview asset hash
    #[serde(skip_serializing_if = "Option::is_none")]
    pub preview_asset: Option<String>,
    /// type of sticker
    #[serde(rename = "type")]
    pub kind: StickerType,
    /// type of sticker format
    pub format_type: StickerFormatType,
    /// whether this guild sticker can be used, may be false due to loss of Server Boosts
    pub available: Option<bool>,
    /// id of the guild that owns this sticker
    pub guild_id: Option<GuildId>,
    /// the user that uploaded the guild sticker
    pub user: Option<User>,
    /// the standard sticker's sort order within its pack
    pub sort_value: Option<i32>,
}
id_impl!(Sticker => StickerId);

serde_repr! {
    pub enum StickerType: u8 {
        /// an official sticker in a pack, part of Nitro or in a removed purchasable pack
        Standard = 1,
        /// a sticker uploaded to a Boosted guild for the guild's members
        Guild = 2,
    }
}

serde_repr! {
    #[allow(clippy::upper_case_acronyms)]
    pub enum StickerFormatType: u8 {
        PNG = 1,
        APNG = 2,
        LOTTIE = 3,
    }
}

/// The smallest amount of data required to render a sticker. A partial sticker object.
#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct StickerItem {
    /// the id of the sticker
    pub id: StickerId,
    /// name of the sticker
    pub name: String,
    /// type of sticker format
    pub format_type: StickerFormatType,
}

/// Represents a pack of standard stickers.
#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct StickerPackObject {
    /// id of the sticker pack
    pub id: StickerPackId,
    /// the stickers in the pack
    pub stickers: Vec<Sticker>,
    /// name of the sticker pack
    pub name: String,
    /// id of the pack's SKU
    pub sku_id: SkuId,
    /// id of a sticker in the pack which is shown as the pack's icon
    pub cover_sticker_id: Option<StickerId>,
    /// description of the sticker pack
    pub description: String,
    /// id of the sticker pack's banner image
    pub banner_asset_id: StickerId,
}

#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct Reaction {
    /// times this emoji has been used to react
    pub count: u32,
    /// whether the current user reacted using this emoji
    pub me: bool,
    /// emoji information
    pub emoji: Emoji,
}

#[derive(Deserialize, Serialize, Eq, PartialEq, Copy, Clone, Debug)]
pub struct Color(u32);

impl Color {
    pub const GOLD: Self = Self::from_rgb(0xBC, 0x9D, 0x46);

    pub const BLUE: Self = Self::from_rgb(0x36, 0x93, 0xD1);
    pub const RED: Self = Self::from_rgb(0xBA, 0x46, 0x50);
}

impl Color {
    pub const fn from_rgb(r: u8, g: u8, b: u8) -> Self {
        Self(r as u32 * 0x10000 + g as u32 * 0x100 + b as u32)
    }
}

impl TryFrom<&str> for Color {
    type Error = ();

    fn try_from(value: &str) -> Result<Self, ()> {
        value.strip_prefix('#')
            .or_else(|| value.strip_prefix("0x"))
            .filter(|trim| trim.len() == 6)
            .filter(|trim| trim.bytes().all(|b| b.is_ascii_hexdigit()))
            .map(|trim| Self::from_rgb(
                u8::from_str_radix(&trim[0..1], 16).unwrap(),
                u8::from_str_radix(&trim[2..3], 16).unwrap(),
                u8::from_str_radix(&trim[4..5], 16).unwrap(),
            ))
            .ok_or(())
    }
}

#[derive(Deserialize, Serialize, Debug, Clone, Default, Eq, PartialEq)]
pub struct Embed {
    /// title of embed
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    /// type of embed (always "rich" for webhook embeds), deprecated
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    embed_type: Option<String>,
    /// description of embed
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// url of embed
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    /// timestamp of embed content
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<DateTime<Utc>>,
    /// color code of the embed
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Color>,
    /// footer information
    #[serde(skip_serializing_if = "Option::is_none")]
    pub footer: Option<EmbedFooter>,
    /// image information
    #[serde(skip_serializing_if = "Option::is_none")]
    pub image: Option<EmbedImage>,
    /// thumbnail information
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thumbnail: Option<EmbedThumbnail>,
    /// video information
    #[serde(skip_serializing_if = "Option::is_none")]
    pub video: Option<EmbedVideo>,
    /// provider information
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider: Option<EmbedProvider>,
    /// author information
    #[serde(skip_serializing_if = "Option::is_none")]
    pub author: Option<EmbedAuthor>,
    /// fields information
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub fields: Vec<EmbedField>,
}

#[derive(Deserialize, Serialize, Debug, Clone, Default, Eq, PartialEq)]
pub struct EmbedThumbnail {
    /// source url of thumbnail (only supports http(s) and attachments)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    /// a proxied url of the thumbnail
    #[serde(skip_serializing_if = "Option::is_none")]
    pub proxy_url: Option<String>,
    /// height of thumbnail
    #[serde(skip_serializing_if = "Option::is_none")]
    pub height: Option<u32>,
    /// width of thumbnail
    #[serde(skip_serializing_if = "Option::is_none")]
    pub width: Option<u32>,
}

#[allow(clippy::needless_pass_by_value)]
impl EmbedThumbnail {
    pub fn new<S: ToString>(url: S) -> Self {
        Self {
            url: Some(url.to_string()),
            proxy_url: None,
            height: None,
            width: None,
        }
    }
}

#[derive(Deserialize, Serialize, Debug, Clone, Default, Eq, PartialEq)]
pub struct EmbedVideo {
    /// source url of video
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    /// height of video
    #[serde(skip_serializing_if = "Option::is_none")]
    pub height: Option<u32>,
    /// width of video
    #[serde(skip_serializing_if = "Option::is_none")]
    pub width: Option<u32>,
}

#[derive(Deserialize, Serialize, Debug, Clone, Default, Eq, PartialEq)]
pub struct EmbedImage {
    /// source url of image (only supports http(s) and attachments)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    /// a proxied url of the image
    #[serde(skip_serializing_if = "Option::is_none")]
    pub proxy_url: Option<String>,
    /// height of image
    #[serde(skip_serializing_if = "Option::is_none")]
    pub height: Option<u32>,
    /// width of image
    #[serde(skip_serializing_if = "Option::is_none")]
    pub width: Option<u32>,
}

#[allow(clippy::needless_pass_by_value)]
impl EmbedImage {
    pub fn new<S: ToString>(url: S) -> Self {
        Self {
            url: Some(url.to_string()),
            proxy_url: None,
            height: None,
            width: None,
        }
    }
}

#[derive(Deserialize, Serialize, Debug, Clone, Default, Eq, PartialEq)]
pub struct EmbedProvider {
    /// name of provider
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// url of provider
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

#[derive(Deserialize, Serialize, Debug, Clone, Default, Eq, PartialEq)]
pub struct EmbedAuthor {
    /// name of author
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// url of author
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    /// url of author icon (only supports http(s) and attachments)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon_url: Option<String>,
    /// a proxied url of author icon
    #[serde(skip_serializing_if = "Option::is_none")]
    pub proxy_icon_url: Option<String>,
}

// todo figure out this api
// impl EmbedAuthor {
//     pub fn new<S: ToString, U: ToString, I: AsRef<Path>>(name: S) -> Self {}
//
//     // pub fn name(mut self, name: )
// }

impl From<&User> for EmbedAuthor {
    fn from(user: &User) -> Self {
        Self {
            name: Some(user.username.clone()),
            url: None,
            icon_url: user.avatar_url::<Png>(),
            proxy_icon_url: None,
        }
    }
}

#[derive(Deserialize, Serialize, Debug, Clone, Eq, PartialEq)]
pub struct EmbedFooter {
    /// footer text
    pub text: String,
    /// url of footer icon (only supports http(s) and attachments)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon_url: Option<String>,
    /// a proxied url of footer icon
    #[serde(skip_serializing_if = "Option::is_none")]
    pub proxy_icon_url: Option<String>,
}

#[allow(clippy::needless_pass_by_value)]
impl EmbedFooter {
    pub fn new<S: ToString>(text: S) -> Self {
        Self {
            text: text.to_string(),
            icon_url: None,
            proxy_icon_url: None,
        }
    }

    pub fn with_icon<S: ToString, U: ToString>(text: S, icon_url: U) -> Self {
        Self {
            text: text.to_string(),
            icon_url: Some(icon_url.to_string()),
            proxy_icon_url: None,
        }
    }

    pub fn icon_url<S: ToString>(mut self, icon_url: S) -> Self {
        self.icon_url = Some(icon_url.to_string());
        self
    }
}

// todo should these be `Cow`s?
#[derive(Deserialize, Serialize, Debug, Clone, Eq, PartialEq)]
pub struct EmbedField {
    /// name of the field
    pub name: String,
    /// value of the field
    pub value: String,
    /// whether or not this field should display inline
    #[serde(default, skip_serializing_if = "bool::is_false")]
    pub inline: bool,
}

// todo these can all be const fn's once const-panicking or something exists
//  also would need name, value to be `Cow`s
#[allow(clippy::needless_pass_by_value)]
impl EmbedField {
    fn checked<S: ToString, V: ToString>(name: S, value: V, inline: bool) -> Self {
        let name = name.to_string();
        let value = value.to_string();
        assert!(!name.is_empty(), "field names cannot be empty (value = {:?})", value);
        assert!(!value.is_empty(), "field values cannot be empty (name = {})", name);
        Self { name, value, inline }
    }

    pub fn new<S: ToString, V: ToString>(name: S, value: V) -> Self {
        Self::checked(name, value, false)
    }

    pub fn new_inline<S: ToString, V: ToString>(name: S, value: V) -> Self {
        Self::checked(name, value, true)
    }

    pub fn blank() -> Self {
        Self::new("\u{200B}", "\u{200B}")
    }

    pub fn blank_inline() -> Self {
        Self::new_inline("\u{200B}", "\u{200B}")
    }

    pub fn blank_tuple_default() -> (&'static str, &'static str) {
        ("\u{200B}", "\u{200B}")
    }

    pub fn blank_tuple() -> (&'static str, &'static str, bool) {
        ("\u{200B}", "\u{200B}", false)
    }

    pub fn blank_inline_tuple() -> (&'static str, &'static str, bool) {
        ("\u{200B}", "\u{200B}", true)
    }

    pub fn name<S: ToString>(mut self, name: S) -> Self {
        self.name = name.to_string();
        self
    }

    pub fn value<S: ToString>(mut self, value: S) -> Self {
        self.value = value.to_string();
        self
    }

    pub fn inline(mut self, inline: bool) -> Self {
        self.inline = inline;
        self
    }
}

impl<N: ToString, V: ToString> From<(N, V)> for EmbedField {
    fn from((name, value): (N, V)) -> Self {
        Self::new(name, value)
    }
}

impl<N: ToString, V: ToString> From<(N, V, bool)> for EmbedField {
    fn from((name, value, inline): (N, V, bool)) -> Self {
        Self::new(name, value).inline(inline)
    }
}

#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct Attachment {
    /// attachment id
    pub id: AttachmentId,
    /// name of file attached
    pub filename: String,
    /// size of file in bytes
    pub size: u32,
    /// source url of file
    pub url: String,
    /// a proxied url of file
    pub proxy_url: String,
    /// height of file (if image)
    pub height: Option<u32>,
    /// width of file (if image)
    pub width: Option<u32>,
}
id_impl!(Attachment => AttachmentId);

#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct ChannelMention {
    /// id of the channel
    pub id: ChannelId,
    /// id of the guild containing the channel
    pub guild_id: GuildId,
    /// the name of the channel
    pub name: String,
    /// the type of channel
    #[serde(rename = "type")]
    pub channel_type: ChannelType,
}
id_impl!(ChannelMention => ChannelId);

/// The allowed mention field allows for more granular control over mentions without various hacks
/// to the message content. This will always validate against message content to avoid phantom pings
/// (e.g. to ping everyone, you must still have `@everyone` in the message content), and check
/// against user/bot permissions.
#[derive(Deserialize, Serialize, Debug, Clone, PartialEq, Eq)]
#[non_exhaustive]
pub struct AllowedMentions {
    /// An array of allowed mention types to parse from the content.
    pub parse: HashSet<AllowedMentionType>,
    /// Array of role_ids to mention (Max size of 100)
    pub roles: Vec<RoleId>,
    /// Array of user_ids to mention (Max size of 100)
    pub users: Vec<UserId>,
    /// For replies, whether to mention the author of the message being replied to (default false)
    pub replied_user: bool,
}

// todo
impl AllowedMentions {
    pub fn suppress_all() -> Self {
        Self {
            parse: Default::default(),
            roles: vec![],
            users: vec![],
            replied_user: false,
        }
    }
}

#[derive(Deserialize, Serialize, Debug, Clone, Copy, Hash, Eq, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum AllowedMentionType {
    /// Controls role mentions
    Roles,
    /// Controls user mentions
    Users,
    /// Controls @everyone and @here mentions
    Everyone,
}

pub trait TextMarkup {
    fn italicize(self) -> String;
    fn bold(self) -> String;
    fn underline(self) -> String;
    fn code_inline(self) -> String;
    fn code_block(self, lang: &str) -> String;
}

fn surround_string(mut string: String, surround: &str) -> String {
    string.insert_str(0, surround);
    string.push_str(surround);
    string
}

impl TextMarkup for String {
    fn italicize(self) -> String {
        surround_string(self, "*")
    }

    fn bold(self) -> String {
        surround_string(self, "**")
    }

    fn underline(self) -> String {
        surround_string(self, "__")
    }

    fn code_inline(self) -> String {
        surround_string(self, "`")
    }

    fn code_block(mut self, lang: &str) -> String {
        self.insert_str(0, &format!("{lang}\n"));
        surround_string(self, "```")
    }
}

impl<'a> TextMarkup for &'a str {
    fn italicize(self) -> String {
        format!("*{self}*")
    }

    fn bold(self) -> String {
        format!("**{self}**")
    }

    fn underline(self) -> String {
        format!("__{self}__")
    }

    fn code_inline(self) -> String {
        format!("`{self}`")
    }

    fn code_block(self, lang: &str) -> String {
        format!("```{lang}\n{self}```")
    }
}

#[derive(Default, Copy, Clone, Eq, PartialEq)]
pub enum TimestampStyle {
    /// 16:20
    ShortTime,
    /// 16:20:30
    LongTime,
    /// 20/04/2021
    ShortDate,
    /// 20 April 2021
    LongDate,
    /// 20 April 2021 16:20
    #[default]
    ShortDateTime,
    /// Tuesday, 20 April 2021 16:20
    LongDateTime,
    /// 2 months ago
    Relative,
}

impl Display for TimestampStyle {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ShortTime => f.write_char('t'),
            Self::LongTime => f.write_char('T'),
            Self::ShortDate => f.write_char('d'),
            Self::LongDate => f.write_char('D'),
            Self::ShortDateTime => f.write_char('f'),
            Self::LongDateTime => f.write_char('F'),
            Self::Relative => f.write_char('R'),
        }
    }
}

pub trait TimestampMarkup {
    fn timestamp_styled(self, style: TimestampStyle) -> String;
}

impl TimestampMarkup for DateTime<Utc> {
    fn timestamp_styled(self, style: TimestampStyle) -> String {
        let timestamp = self.timestamp();
        format!("<t:{timestamp}:{style}")
    }
}

#[cfg(test)]
mod message_tests {
    use super::*;

    fn assert(json: &str) {
        let message: Message = serde_json::from_str(json).unwrap();
        let back = serde_json::to_string_pretty(&message).unwrap();
        assert_eq!(json, back)
    }

    #[test]
    fn message() {
        assert(r#"{
  "id": "334385199974967042",
  "channel_id": "290926798999357250",
  "author": {
    "id": "53908099506183680",
    "username": "Mason",
    "discriminator": "9999",
    "avatar": "a_bab14f271d565501444b2ca3be944b25"
  },
  "content": "Supa Hot",
  "timestamp": "2017-07-11T17:27:07.299Z",
  "edited_timestamp": null,
  "tts": false,
  "mention_everyone": false,
  "mentions": [],
  "mention_roles": [],
  "attachments": [],
  "embeds": [],
  "reactions": [
    {
      "count": 1,
      "me": false,
      "emoji": {
        "name": "🔥"
      }
    }
  ],
  "pinned": false,
  "type": 0
}"#)
    }

    #[test]
    fn crossposted() {
        assert(r#"{
  "id": "334385199974967042",
  "channel_id": "290926798999357250",
  "author": {
    "id": "53908099506183680",
    "username": "Mason",
    "discriminator": "9999",
    "avatar": "a_bab14f271d565501444b2ca3be944b25"
  },
  "content": "Big news! In this <#278325129692446722> channel!",
  "timestamp": "2017-07-11T17:27:07.299Z",
  "edited_timestamp": null,
  "tts": false,
  "mention_everyone": false,
  "mentions": [],
  "mention_roles": [],
  "mention_channels": [
    {
      "id": "278325129692446722",
      "guild_id": "278325129692446720",
      "name": "big-news",
      "type": 5
    }
  ],
  "attachments": [],
  "embeds": [],
  "reactions": [
    {
      "count": 1,
      "me": false,
      "emoji": {
        "name": "🔥"
      }
    }
  ],
  "pinned": false,
  "message_reference": {
    "message_id": "306588351130107906",
    "channel_id": "278325129692446722",
    "guild_id": "278325129692446720"
  },
  "flags": 2,
  "type": 0
}"#)
    }
}